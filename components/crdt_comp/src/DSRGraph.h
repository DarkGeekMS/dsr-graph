// **********************************************************************
//
// Copyright (c) 2003-2018 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.1
//
// <auto-generated>
//
// Generated from file `DSRGraph.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __DSRGraph_h__
#define __DSRGraph_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace RoboCompDSR
{

using Attribs = ::std::map<::std::string, ::std::string>;

struct EdgeAttribs
{
    ::std::string label;
    int from;
    int to;
    Attribs attrs;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const int&, const int&, const Attribs&> ice_tuple() const
    {
        return std::tie(label, from, to, attrs);
    }
    friend std::ostream &operator<<(std::ostream &output, const EdgeAttribs &ea_) {
            output << "EdgeAttribs["<<ea_.label<<": from:" << ea_.from << ", to:"<<ea_.to<<std::endl<<" Attribs:";
            for (auto [k,v] : ea_.attrs)
                output << k <<":"<<v <<" - ";
            return output;
    };
};

using FanOut = ::std::map<int, EdgeAttribs>;

struct Content
{
    ::std::string type;
    int id;
    Attribs attrs;
    FanOut fano;
    int causalContext;
    int dotCloud;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const int&, const Attribs&, const FanOut&, const int&, const int&> ice_tuple() const
    {
        return std::tie(type, id, attrs, fano, causalContext, dotCloud);
    }
    bool operator==(const Content &c_) const {
            if (this == &c_) {
                return true;
            }
            if (id != c_.id) {
                return false;
            }
            return true;
        }

        bool operator<(const Content &c_) const {
            if (this == &c_) {
                return false;
            }
            if (id < c_.id) {
                return true;
            } else if (c_.id < id) {
                return false;
            }
            return false;
        }

        bool operator!=(const Content &c_) const {
            return !operator==(c_);
        }

        bool operator<=(const Content &c_) const {
            return operator<(c_) || operator==(c_);
        }

        bool operator>(const Content &c_) const {
            return !operator<(c_) && !operator==(c_);
        }

        bool operator>=(const Content &c_) const {
            return !operator<(c_);
        }

        friend std::ostream &operator<<(std::ostream &output, const Content &c_) {
            output <<"Content:["<<c_.id<<"," << c_.type <<"], Attribs:[";
            for (auto [k,v] : c_.attrs)
                output << k <<":"<< v <<" - ";
            output<<"], FanOut:[";
            for (auto [k,v] : c_.fano)
                output << k <<":"<< v;
            output<<"], Contexto-ICE:[CC:"<<c_.causalContext<<", DC:"<<c_.dotCloud<<"]";
            return output;
            }
};

struct GraphRequest
{
    ::std::string from;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(from);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::RoboCompDSR::EdgeAttribs>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::EdgeAttribs, S>
{
    static void read(S* istr, ::RoboCompDSR::EdgeAttribs& v)
    {
        istr->readAll(v.label, v.from, v.to, v.attrs);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::Content>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 15;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::Content, S>
{
    static void read(S* istr, ::RoboCompDSR::Content& v)
    {
        istr->readAll(v.type, v.id, v.attrs, v.fano, v.causalContext, v.dotCloud);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::GraphRequest>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::GraphRequest, S>
{
    static void read(S* istr, ::RoboCompDSR::GraphRequest& v)
    {
        istr->readAll(v.from);
    }
};

}
/// \endcond

#else // C++98 mapping

namespace RoboCompDSR {

    typedef ::std::map<::std::string, ::std::string> Attribs;

    struct EdgeAttribs {
        ::std::string label;
        ::Ice::Int from;
        ::Ice::Int to;
        Attribs attrs;
    };

    typedef ::std::map <Ice::Int, RoboCompDSR::EdgeAttribs> FanOut;

    struct Content {
        ::std::string type;
        ::Ice::Int id;
        Attribs attrs;
        FanOut fano;
        ::Ice::Int causalContext;
        ::Ice::Int dotCloud;

        bool operator==(const Content &c_) const {
            if (this == &c_) {
                return true;
            }
            if (id != c_.id) {
                return false;
            }
            return true;
        }

        bool operator<(const Content &c_) const {
            if (this == &c_) {
                return false;
            }
            if (id < c_.id) {
                return true;
            } else if (c_.id < id) {
                return false;
            }
            return false;
        }

        bool operator!=(const Content &c_) const {
            return !operator==(c_);
        }

        bool operator<=(const Content &c_) const {
            return operator<(c_) || operator==(c_);
        }

        bool operator>(const Content &c_) const {
            return !operator<(c_) && !operator==(c_);
        }

        bool operator>=(const Content &c_) const {
            return !operator<(c_);
        }

        friend std::ostream &operator<<(std::ostream &output, const Content &c_) {
            output << "Content: " << c_.id;
            return output;
        };
    };

    struct GraphRequest {
        ::std::string from;

        bool operator==(const GraphRequest &rhs_) const {
            if (this == &rhs_) {
                return true;
            }
            if (from != rhs_.from) {
                return false;
            }
            return true;
        }

        bool operator<(const GraphRequest &rhs_) const {
            if (this == &rhs_) {
                return false;
            }
            if (from < rhs_.from) {
                return true;
            } else if (rhs_.from < from) {
                return false;
            }
            return false;
        }

        bool operator!=(const GraphRequest &rhs_) const {
            return !operator==(rhs_);
        }

        bool operator<=(const GraphRequest &rhs_) const {
            return operator<(rhs_) || operator==(rhs_);
        }

        bool operator>(const GraphRequest &rhs_) const {
            return !operator<(rhs_) && !operator==(rhs_);
        }

        bool operator>=(const GraphRequest &rhs_) const {
            return !operator<(rhs_);
        }
    };

}

/// \cond STREAM
namespace Ice {

    template<>
    struct StreamableTraits<::RoboCompDSR::EdgeAttribs> {
        static const StreamHelperCategory helper = StreamHelperCategoryStruct;
        static const int minWireSize = 10;
        static const bool fixedLength = false;
    };

    template<typename S>
    struct StreamWriter<::RoboCompDSR::EdgeAttribs, S> {
        static void write(S *ostr, const ::RoboCompDSR::EdgeAttribs &v) {
            ostr->write(v.label);
            ostr->write(v.from);
            ostr->write(v.to);
            ostr->write(v.attrs);
        }
    };

    template<typename S>
    struct StreamReader<::RoboCompDSR::EdgeAttribs, S> {
        static void read(S *istr, ::RoboCompDSR::EdgeAttribs &v) {
            istr->read(v.label);
            istr->read(v.from);
            istr->read(v.to);
            istr->read(v.attrs);
        }
    };

    template<>
    struct StreamableTraits<::RoboCompDSR::Content> {
        static const StreamHelperCategory helper = StreamHelperCategoryStruct;
        static const int minWireSize = 15;
        static const bool fixedLength = false;
    };

    template<typename S>
    struct StreamWriter<::RoboCompDSR::Content, S> {
        static void write(S *ostr, const ::RoboCompDSR::Content &v) {
            ostr->write(v.type);
            ostr->write(v.id);
            ostr->write(v.attrs);
            ostr->write(v.fano);
            ostr->write(v.causalContext);
            ostr->write(v.dotCloud);
        }
    };

    template<typename S>
    struct StreamReader<::RoboCompDSR::Content, S> {
        static void read(S *istr, ::RoboCompDSR::Content &v) {
            istr->read(v.type);
            istr->read(v.id);
            istr->read(v.attrs);
            istr->read(v.fano);
            istr->read(v.causalContext);
            istr->read(v.dotCloud);
        }
    };

    template<>
    struct StreamableTraits<::RoboCompDSR::GraphRequest> {
        static const StreamHelperCategory helper = StreamHelperCategoryStruct;
        static const int minWireSize = 1;
        static const bool fixedLength = false;
    };

    template<typename S>
    struct StreamWriter<::RoboCompDSR::GraphRequest, S> {
        static void write(S *ostr, const ::RoboCompDSR::GraphRequest &v) {
            ostr->write(v.from);
        }
    };

    template<typename S>
    struct StreamReader<::RoboCompDSR::GraphRequest, S> {
        static void read(S *istr, ::RoboCompDSR::GraphRequest &v) {
            istr->read(v.from);
        }
    };

}
/// \endcond

#endif

#include <IceUtil/PopDisableWarnings.h>

#endif
